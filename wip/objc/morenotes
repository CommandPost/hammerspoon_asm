Objective-C type encodings
    c               A char
    i               An int
    s               A short
    l               A long    l is treated as a 32-bit quantity on 64-bit programs.
    q               A long long
    C               An unsigned char
    I               An unsigned int
    S               An unsigned short
    L               An unsigned long
    Q               An unsigned long long
    f               A float
    d               A double
    B               A C++ bool or a C99 _Bool
    v               A void
    *               A character string (char *)
    @               An object (whether statically typed or typed id)
    #               A class object (Class)
    :               A method selector (SEL)
    [array type]    An array
    {name=type...}  A structure
    (name=type...)  A union
    bnum            A bit field of num bits
    ^type           A pointer to type
    ?               An unknown type (among other things, this code is used for function pointers)

    The type code for an array is enclosed within square brackets; the number of elements in the array is specified immediately after the open bracket, before the array type. For example, an array of 12 pointers to floats would be encoded as: [12^f]

    Structures are specified within braces, and unions within parentheses. The structure tag is listed first, followed by an equal sign and the codes for the fields of the structure listed in sequence. For example, the structure

    typedef struct example {
        id   anObject;
        char *aString;
        int  anInt;
    } Example;
    would be encoded like this: {example=@*i}

    The same encoding results whether the defined type name (Example) or the structure tag (example) is passed to @encode(). The encoding for a structure pointer carries the same amount of information about the structure’s fields:

    ^{example=@*i}

    However, another level of indirection removes the internal type specification:

    ^^{example}

    Objects are treated like structures. For example, passing the NSObject class name to @encode() yields this encoding:

    {NSObject=#}
    The NSObject class declares just one instance variable, isa, of type Class.

    Note that although the @encode() directive doesn’t return them, the runtime system uses the additional encodings listed in Table 6-2 for type qualifiers when they’re used to declare methods in a protocol.


Objective-C method encodings
    r               const
    n               in
    N               inout
    o               out
    O               bycopy
    R               byref
    V               oneway

Declared property type encodings
    R               The property is read-only (readonly).
    C               The property is a copy of the value last assigned (copy).
    &               The property is a reference to the value last assigned (retain).
    N               The property is non-atomic (nonatomic).
    G<name>         The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).
    S<name>         The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).
    D               The property is dynamic (@dynamic).
    W               The property is a weak reference (__weak).
    P               The property is eligible for garbage collection.
    t<encoding>     Specifies the type using old-style encoding.
