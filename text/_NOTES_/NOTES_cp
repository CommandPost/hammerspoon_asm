Module Functions
  cp.utf16.char(bigEndian, ...) -> string
  cp.utf16.codepoint(bigEndian, s [, i [, j]]) -> integer...
  cp.utf16.codes(bigEndian, s) -> iterator
  cp.utf16.len (bigEndian, s [, i [, j]]) -> number | boolean, number
  cp.utf16.offset (bigEndian, s, n [, i]) -> number

Module Functions
  cp.utf16.be.char(...) -> string
  cp.utf16.be.codepoint(s [, i [, j]]) -> integer...
  cp.utf16.be.codes(s) -> iterator
  cp.utf16.be.len (s [, i [, j]]) -> number | boolean, number
  cp.utf16.be.offset (s, n [, i]) -> number

Module Functions
  cp.utf16.le.char(...) -> string
  cp.utf16.le.codepoint(s [, i [, j]]) -> integer...
  cp.utf16.le.codes(s) -> iterator
  cp.utf16.le.len (s [, i [, j]]) -> number | boolean, number
  cp.utf16.le.offset (s, n [, i]) -> number



Module Constructors
  cp.text.char(...) -> text
  cp.text.fromCodepoints(codepoints[, i[, j]]) -> text
  cp.text.fromFile(path[, encoding]) -> text
  cp.text.fromString(value[, encoding]) -> text
  cp.text.matcher(pattern[, plain]) -> cp.text.matcher

Module Functions
  cp.text.is(value) -> boolean

Module Methods
  cp.text:encode([encoding]) -> string
  cp.text:find(pattern [, init [, plain]])
  cp.text:len() -> number
  cp.text:match(pattern[, start]) -> ...
  cp.text:sub(i [, j]) -> cp.text

Module Constants
  cp.text.encoding

Module Methods
  cp.text.matcher:find(value[, start]) -> number, number, ...
  cp.text.matcher:gmatch(pattern[, start]) -> function
  cp.text.matcher:gmatch(value) -> function
  cp.text.matcher:gsub(value, repl, limit) -> text, number
  cp.text.matcher:match(value[, start]) -> ...
